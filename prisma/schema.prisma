// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/* ======================= USUARIOS ======================= */

model User {
  id                   Int       @id @default(autoincrement())
  name                 String    @db.VarChar(100)
  email                String    @unique @db.VarChar(254)
  password             String    @db.VarChar(100)
  role                 String    @db.VarChar(16)
  rut                  String?   @unique @db.VarChar(16)
  birthDate            DateTime? @db.Date                  // fecha de nacimiento
  canSell              Boolean   @default(true)
  isVerified           Boolean   @default(false)
  isActive             Boolean   @default(true)
  deletedAt            DateTime?
  anonymizedAt         DateTime?
  documentUrl          String?   @db.VarChar(1024)
  resetPasswordToken   String?   @db.VarChar(255)
  resetPasswordExpires DateTime?
  tokenVersion         Int       @default(0)
  failedLoginCount     Int       @default(0)
  lockUntil            DateTime?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt @default(now())

  events               Event[]       @relation("OrganizerEvents")
  reservations         Reservation[] @relation("ReservationBuyer")

  application          OrganizerApplication?

  // Reventa
  resaleListings       ResaleListing[]
  resaleOrdersBought   ResaleOrder[]   @relation("ResaleOrderBuyer")
  ticketAssets         TicketAsset[]   @relation("TicketAssetUploader")

  // Aprobaciones de tickets como superadmin (lado inverso)
  reservationsApproved Reservation[] @relation("ReservationApprovedBy")

  // Marketplace / PSP
  connectedAccount     ConnectedAccount?

  @@index([role, isVerified])
  @@index([isActive])
  @@index([deletedAt])
  @@index([lockUntil])
  @@index([failedLoginCount])
}

/* ======================= TIPOS DE EVENTOS ======================= */

enum EventType {
  OWN      // evento propio
  RESALE   // reventa
}

/* ======================= EVENTOS ======================= */

model Event {
  id            Int       @id @default(autoincrement())
  title         String    @db.VarChar(120)
  description   String    @db.VarChar(4000)
  date          DateTime
  location      String    @db.VarChar(120)
  city          String?   @db.VarChar(120)
  commune       String?   @db.VarChar(120)
  capacity      Int
  price         Int       @default(0)
  priceBase     Int?
  approved      Boolean   @default(false)
  coverImageUrl String?   @db.VarChar(1024)
  eventType     EventType @default(OWN)

  organizer     User      @relation("OrganizerEvents", fields: [organizerId], references: [id])
  organizerId   Int

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt @default(now())

  reservations  Reservation[]
  tickets       Ticket[]
  sections      EventSection[]  // Para eventos OWN

  // (LEGADO) Datos bancarios por evento ‚Äî se recomienda moverlos al perfil/PSP del organizador
  payoutBankName      String? @db.VarChar(80)
  payoutAccountType   String? @db.VarChar(16)
  payoutAccountNumber String? @db.VarChar(30)
  payoutHolderName    String? @db.VarChar(100)
  payoutHolderRut     String? @db.VarChar(16)

  // Reventa
  resaleListings ResaleListing[]

  @@index([organizerId])
  @@index([approved])
  @@index([date])
  @@index([eventType])
}

/* ===================== TICKETS (Solo RESALE) ===================== */

model Ticket {
  id            Int       @id @default(autoincrement())
  event         Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId       Int

  // Metadata del ticket fisico (solo RESALE)
  ticketCode    String    @db.VarChar(100)
  row           String    @db.VarChar(20)
  seat          String    @db.VarChar(20)
  zone          String?   @db.VarChar(50)
  level         String?   @db.VarChar(50)
  description   String?   @db.VarChar(200)

  // Archivo del ticket original
  imageFilePath String    @db.VarChar(1024)
  imageFileName String    @db.VarChar(255)
  imageMime     String    @db.VarChar(127)
  imageChecksum String?   @db.VarChar(64)

  // Estado de venta
  sold          Boolean   @default(false)
  soldAt        DateTime?
  
  // Relacion 1-to-1 con Reservation
  reservationId Int?      @unique
  reservation   Reservation? @relation(fields: [reservationId], references: [id])

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt @default(now())

  @@index([eventId, sold])
  @@unique([eventId, ticketCode])
}

/* ===================== SECCIONES (Solo OWN) ===================== */

model EventSection {
  id            Int      @id @default(autoincrement())
  event         Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId       Int

  // Metadata de la seccion
  name          String   @db.VarChar(100)
  rowStart      String?  @db.VarChar(20)
  rowEnd        String?  @db.VarChar(20)
  seatsPerRow   Int?
  seatStart     Int?
  seatEnd       Int?
  totalCapacity Int      // Calculado
  description   String?  @db.VarChar(200)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt @default(now())

  @@index([eventId])
}

/* ============ RESERVAS (COMPRA PRIMARIA) ============ */

enum ReservationStatus {
  PENDING_PAYMENT
  PAID
  CANCELED
  EXPIRED
}

/* Cadena de custodia de ticket (escrow) */
enum FulfillmentStatus {
  WAITING_TICKET
  TICKET_UPLOADED
  TICKET_APPROVED
  TICKET_REJECTED
  DELIVERED
}

/* Reembolso para reservas vencidas */
enum RefundStatus {
  NONE
  REQUESTED
  SUCCEEDED
  FAILED
}

model Reservation {
  id        Int               @id @default(autoincrement())
  event     Event             @relation(fields: [eventId], references: [id])
  eventId   Int
  buyer     User              @relation("ReservationBuyer", fields: [buyerId], references: [id])
  buyerId   Int
  quantity  Int

  // Agrupacion de multiples reservas en una compra
  purchaseGroupId String?        @db.VarChar(36)
  sectionId       Int?           // FK a EventSection para eventos OWN con secciones

  // Hold + pago
  status    ReservationStatus @default(PENDING_PAYMENT)
  code      String            @db.VarChar(36) @unique @default(uuid())
  amount    Int               @default(0)
  expiresAt DateTime?
  paidAt    DateTime?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt @default(now())

  // 1‚Äì1 con Payment (Payment.reservationId es el FK)
  payment   Payment?

  // Relacion con Ticket (solo RESALE) - vinculacion inversa
  ticket    Ticket?

  // Para eventos OWN: tickets generados (1 PDF por ticket comprado)
  generatedTickets  GeneratedTicket[]
  
  // LEGACY: campos deprecados, mantener por compatibilidad
  seatAssignment    String?  @db.VarChar(500)  // "A15, A16, A17"
  generatedPdfPath  String?  @db.VarChar(1024)
  qrCode            String?  @db.VarChar(100)
  scanned           Boolean  @default(false)
  scannedAt         DateTime?

  // Flujo de ticket (LEGACY - mantener para compatibilidad)
  fulfillmentStatus  FulfillmentStatus @default(WAITING_TICKET)
  ticketFilePath     String?           @db.VarChar(1024)
  ticketFileName     String?           @db.VarChar(255)
  ticketMime         String?           @db.VarChar(127)
  ticketChecksum     String?           @db.VarChar(64)
  ticketUploadedAt   DateTime?
  approvedAt         DateTime?
  rejectionReason    String?
  deliveredAt        DateTime?

  approvedByAdminId  Int?
  approvedByAdmin    User?             @relation("ReservationApprovedBy", fields: [approvedByAdminId], references: [id])

  // Plazo para subir ticket + tracking de reembolso
  ticketUploadDeadlineAt DateTime?
  refundStatus           RefundStatus   @default(NONE)
  refundedAt             DateTime?
  refundId               String?        @db.VarChar(100)
  refundReason           String?        @db.VarChar(255)

  // Payouts que referencian esta reserva (opcional)
  payouts Payout[]

  // üîΩ Inversa libro mayor
  ledgerEntries LedgerEntry[] @relation("ReservationLedger")

  @@index([eventId])
  @@index([buyerId])
  @@index([eventId, status, expiresAt])
  @@index([fulfillmentStatus])
  @@index([approvedByAdminId])
  @@index([status, ticketUploadDeadlineAt])
  @@index([refundStatus])
  @@index([qrCode])
  @@index([scanned])
  @@index([purchaseGroupId])
  @@index([sectionId])
}

/* ============ TICKETS GENERADOS (OWN) ============ */

model GeneratedTicket {
  id            Int      @id @default(autoincrement())
  reservation   Reservation @relation(fields: [reservationId], references: [id], onDelete: Cascade)
  reservationId Int
  
  // Datos del ticket individual
  ticketNumber  Int      // 1, 2, 3... (n√∫mero dentro de la reserva)
  seatNumber    String?  @db.VarChar(50)  // "A15", "VIP-23", etc.
  qrCode        String   @db.VarChar(100) @unique
  pdfPath       String   @db.VarChar(1024)
  
  // Estado del ticket
  scanned       Boolean  @default(false)
  scannedAt     DateTime?
  scannedBy     String?  @db.VarChar(100)  // Identificador del esc√°ner/usuario
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt @default(now())

  @@index([reservationId])
  @@index([qrCode])
  @@index([scanned])
}

/* ============ SOLICITUD ORGANIZADOR ============ */

enum ApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

model OrganizerApplication {
  id           Int               @id @default(autoincrement())
  userId       Int               @unique
  legalName    String            @db.VarChar(150)
  taxId        String            @db.VarChar(32)
  phone        String?           @db.VarChar(30)
  notes        String?           @db.Text
  idCardImage  String            @db.VarChar(1024)
  status       ApplicationStatus @default(PENDING)
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  payoutBankName      String     @db.VarChar(80)
  payoutAccountType   AccountType
  payoutAccountNumber String     @db.VarChar(30)
  payoutHolderName    String     @db.VarChar(100)
  payoutHolderRut     String     @db.VarChar(16)

  user         User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
}

/* =================== PSP / Marketplace =================== */

enum PaymentStatus {
  INITIATED
  AUTHORIZED
  CAPTURED
  COMMITTED
  VOIDED
  FAILED
  ABORTED
  TIMEOUT
  REFUNDED
}

enum ConnectedOnboardingStatus {
  PENDING
  REQUIRED
  COMPLETE
  RESTRICTED
}

// Tipo de cuenta ‚ÄúCuenta de cobro‚Äù
enum AccountType {
  VISTA
  CORRIENTE
  AHORRO
  RUT
}

/* NEW: Pol√≠tica de captura (para aprobar antes de capturar) */
enum CapturePolicy {
  IMMEDIATE
  MANUAL_ON_APPROVAL
}

/* NEW: Estado de escrow/liberaci√≥n del PSP */
enum PaymentEscrowStatus {
  NONE
  HELD
  RELEASED
  RELEASE_FAILED
  EXPIRED
}

model ConnectedAccount {
  id               Int                        @id @default(autoincrement())
  userId           Int                        @unique
  psp              String                     @db.VarChar(32)     // "WEBPAY" | "STRIPE" | "MP" | "KUSHKI" ...
  pspAccountId     String                     @unique @db.VarChar(128)
  onboardingStatus ConnectedOnboardingStatus  @default(PENDING)
  payoutsEnabled   Boolean                    @default(false)
  createdAt        DateTime                   @default(now())
  updatedAt        DateTime                   @updatedAt

  // Datos de cuenta de cobro (si el PSP requiere datos bancarios del destinatario)
  payoutBankName      String?     @db.VarChar(80)
  payoutAccountType   AccountType?
  payoutAccountNumber String?     @db.VarChar(30)
  payoutHolderName    String?     @db.VarChar(100)
  payoutHolderRut     String?     @db.VarChar(16)

  user                User                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  payouts             Payout[]
  destinationPayments Payment[]                  @relation("DestinationAccount")

  // üîΩ Inversa libro mayor por cuenta
  ledgerEntries       LedgerEntry[]

  @@index([psp, pspAccountId])
}

enum PayoutStatus {
  PENDING
  SCHEDULED
  IN_TRANSIT
  PAID
  FAILED
  CANCELED
}

/* NEW: Fuente del payout (nuestro sistema vs iniciado por PSP) */
enum PayoutSource {
  INTERNAL
  PSP
}

model Payout {
  id               Int              @id @default(autoincrement())
  accountId        Int
  paymentId        Int?
  reservationId    Int?
  amount           Int
  currency         String           @default("CLP")
  status           PayoutStatus     @default(PENDING)

  // Identificadores / idempotencia
  pspPayoutId      String?          @unique @db.VarChar(128)
  idempotencyKey   String           @unique @db.VarChar(80)
  externalStatus   String?          @db.VarChar(64)

  // Scheduling / timestamps
  scheduledFor     DateTime?
  paidAt           DateTime?

  // Errores y reintentos
  retries          Int              @default(0)
  failureCode      String?          @db.VarChar(50)
  failureMessage   String?          @db.VarChar(255)

  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Qui√©n ejecuta el payout (split del PSP vs interno)
  source           PayoutSource     @default(INTERNAL)

  account          ConnectedAccount @relation(fields: [accountId], references: [id])
  payment          Payment?         @relation(fields: [paymentId], references: [id])
  reservation      Reservation?     @relation(fields: [reservationId], references: [id])

  // Libro mayor
  ledgerEntries    LedgerEntry[]    @relation("PayoutLedger")

  @@unique([reservationId])
  @@index([accountId])
  @@index([status, updatedAt])
  @@index([paymentId])
  @@index([source])
}

/* =================== PAGOS =================== */

model Payment {
  id             Int            @id @default(autoincrement())

  // 1‚Äì1 con Reservation (opcional para reventa)
  reservation    Reservation?   @relation(fields: [reservationId], references: [id])
  reservationId  Int?           @unique

  // 1‚Äì1 con ResaleOrder (opcional)
  resaleOrder    ResaleOrder?   @relation("ResalePayment")

  // Datos principales
  token          String?        @unique @db.VarChar(128)
  buyOrder       String         @unique @db.VarChar(100)
  sessionId      String         @db.VarChar(100)
  amount         Int
  currency       String         @default("CLP")
  status         PaymentStatus  @default(INITIATED)

  // Marketplace (split)
  destinationAccountId Int?
  applicationFeeAmount Int?
  netAmount            Int?
  isSplit              Boolean       @default(false)

  // Metadatos PSP gen√©ricos
  psp               String?       @db.VarChar(32)
  pspPaymentId      String?       @db.VarChar(128)
  pspChargeId       String?       @db.VarChar(128)
  pspMetadata       Json?

  // Metadatos TBK / tarjeta (si aplica)
  authorizationCode   String?   @db.VarChar(20)
  paymentTypeCode     String?   @db.VarChar(10)
  installmentsNumber  Int?
  responseCode        Int?
  accountingDate      String?   @db.VarChar(8)  // "MMDD"
  transactionDate     DateTime?
  cardLast4           String?   @db.VarChar(4)
  vci                 String?   @db.VarChar(32)

  // Deferred capture (autorizaci√≥n y captura)
  isDeferredCapture      Boolean        @default(false)
  authorizedAmount       Int?
  authorizationExpiresAt DateTime?
  capturedAmount         Int?
  capturedAt             DateTime?
  captureId              String?        @db.VarChar(100)

  // NEW: pol√≠tica de captura y estado de escrow/liberaci√≥n
  capturePolicy    CapturePolicy       @default(IMMEDIATE)
  escrowStatus     PaymentEscrowStatus @default(NONE)
  escrowHoldId     String?             @db.VarChar(128)
  escrowExpiresAt  DateTime?
  escrowReleasedAt DateTime?
  escrowReleaseId  String?             @db.VarChar(128)

  voidedAt            DateTime?

  // Auditor√≠a
  commerceCode    String?       @db.VarChar(20)
  environment     String?       @db.VarChar(16)

  // Reembolsos
  refundedAmount  Int?
  lastRefundAt    DateTime?

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt @default(now())

  destinationAccount ConnectedAccount? @relation("DestinationAccount", fields: [destinationAccountId], references: [id])
  payouts            Payout[]

  // üîΩ Inversa libro mayor
  ledgerEntries      LedgerEntry[] @relation("PaymentLedger")

  @@index([status])
  @@index([token])
  @@index([buyOrder])
  @@index([destinationAccountId])
  @@index([psp])
  @@index([pspPaymentId])
  @@index([escrowStatus])
  @@index([capturePolicy])
}

/* =================== LIBRO MAYOR =================== */

model LedgerEntry {
  id            Int       @id @default(autoincrement())
  accountId     Int
  type          String    @db.VarChar(32)   // SALE | FEE | REFUND | HOLD_RELEASE | PAYOUT | ADJUSTMENT...
  direction     String    @db.VarChar(8)    // DEBIT | CREDIT
  amount        Int
  currency      String    @default("CLP")
  memo          String?   @db.VarChar(255)
  createdAt     DateTime  @default(now())

  // FKs opcionales para trazar el origen
  paymentId     Int?
  reservationId Int?
  payoutId      Int?

  // Relaciones (con nombres para evitar ambig√ºedad)
  payment       Payment?      @relation("PaymentLedger",     fields: [paymentId],     references: [id])
  reservation   Reservation?  @relation("ReservationLedger", fields: [reservationId], references: [id])
  payout        Payout?       @relation("PayoutLedger",      fields: [payoutId],      references: [id])

  account       ConnectedAccount @relation(fields: [accountId], references: [id])

  @@index([accountId])
  @@index([paymentId])
  @@index([reservationId])
  @@index([payoutId])
}

/* =================== REVENTA (ESCROW) =================== */

enum ResaleListingStatus {
  ACTIVE
  PAUSED
  SOLD
  CANCELED
  EXPIRED
}

enum ResaleOrderStatus {
  AWAITING_PAYMENT
  AWAITING_TICKET
  UNDER_REVIEW
  DELIVERED
  AWAITING_CONFIRMATION
  RELEASED
  REFUND_REQUESTED
  REFUNDED
  CANCELED
  EXPIRED
}

model ResaleListing {
  id        Int                  @id @default(autoincrement())
  eventId   Int
  sellerId  Int
  askPrice  Int
  currency  String               @default("CLP")
  status    ResaleListingStatus  @default(ACTIVE)
  expiresAt DateTime?
  createdAt DateTime             @default(now())
  updatedAt DateTime             @updatedAt

  event     Event                @relation(fields: [eventId], references: [id])
  seller    User                 @relation(fields: [sellerId], references: [id])
  orders    ResaleOrder[]

  @@index([eventId])
  @@index([sellerId])
  @@index([status])
}

model ResaleOrder {
  id                    Int                 @id @default(autoincrement())
  listingId             Int
  buyerId               Int
  status                ResaleOrderStatus   @default(AWAITING_PAYMENT)
  amount                Int
  currency              String              @default("CLP")
  paymentId             Int?                @unique
  deliveredAt           DateTime?
  releasedAt            DateTime?
  canceledAt            DateTime?
  expiresUploadAt       DateTime?
  buyerConfirmDeadline  DateTime?
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt

  listing               ResaleListing       @relation(fields: [listingId], references: [id])
  buyer                 User                @relation("ResaleOrderBuyer", fields: [buyerId], references: [id])
  payment               Payment?            @relation("ResalePayment", fields: [paymentId], references: [id])
  assets                TicketAsset[]
  timeline              EscrowTimeline[]

  @@index([listingId])
  @@index([buyerId])
  @@index([status])
}

model TicketAsset {
  id           Int         @id @default(autoincrement())
  orderId      Int
  uploaderId   Int
  path         String
  sha256       String
  filename     String
  contentType  String
  size         Int
  parsedCode   String?
  status       String       @default("RECEIVED") // RECEIVED | APPROVED | REJECTED
  createdAt    DateTime     @default(now())

  order        ResaleOrder  @relation(fields: [orderId], references: [id])
  uploader     User         @relation("TicketAssetUploader", fields: [uploaderId], references: [id])

  @@unique([sha256])
  @@index([orderId])
  @@index([uploaderId])
}

model EscrowTimeline {
  id        Int          @id @default(autoincrement())
  orderId   Int
  type      String       // ORDER_CREATED, PAYMENT_APPROVED, TICKET_UPLOADED, etc.
  message   String
  meta      Json?
  createdAt DateTime     @default(now())

  order     ResaleOrder  @relation(fields: [orderId], references: [id])

  @@index([orderId])
}

enum ConfigCategory {
  TICKET_LIMIT
  PRICE_LIMIT
  FIELD_LIMIT
  BUSINESS_RULE
}

enum ConfigDataType {
  INTEGER
  DECIMAL
  STRING
  BOOLEAN
}

model SystemConfig {
  id          Int            @id @default(autoincrement())
  category    ConfigCategory
  key         String         @unique @db.VarChar(100)
  value       String         @db.VarChar(500)
  dataType    ConfigDataType
  description String?        @db.VarChar(500)
  isEditable  Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt @default(now())

  @@index([category])
  @@index([key])
}

model TicketLimitConfig {
  id          Int      @id @default(autoincrement())
  eventType   String   @unique @db.VarChar(20)
  minCapacity Int
  maxCapacity Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt @default(now())

  @@index([eventType])
}

model PriceLimitConfig {
  id                  Int      @id @default(autoincrement())
  minPrice            Int
  maxPrice            Int
  resaleMarkupPercent Int
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt @default(now())
}

model FieldLimitConfig {
  id          Int      @id @default(autoincrement())
  fieldName   String   @unique @db.VarChar(100)
  maxLength   Int
  context     String?  @db.VarChar(100)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt @default(now())

  @@index([fieldName])
  @@index([context])
}


















